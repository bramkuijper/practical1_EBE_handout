[["index.html", "Evolutionary Behavioural Ecology: practical on Modeling Evolution Chapter 1 Practicals on evolutionary models using R 1.1 Learning objectives 1.2 Opening the R environment", " Evolutionary Behavioural Ecology: practical on Modeling Evolution Bram Kuijper 2021-09-30 Chapter 1 Practicals on evolutionary models using R During the following two practicals, we will try to implement some basic evolutionary models in R. The first practical will focus on the evolution of aggressive vs evasive behaviour. The second practical will focus on the evolution of cooperation and conflict. I am certainly no R expert myself, so this is as much a learning process for you as it is for me. 1.1 Learning objectives After this practical, you… should be able to use R to implement short programs understand how we can develop simple population genetics models in R should be able to explain why models necessarily include many limiting assumptions should be able to inspect your model and draw conclusions from it. 1.2 Opening the R environment To provide you with a standardized environment during this practical session, you will have to log into to the University of Exeter’s Rstudio server. Of course, you are welcome to try to do the same using your installation of R on your own computer, but we might run into problems regarding the installation of some packages, hence we ask you to stick to the rstudio server during the practical. "],["a-brief-r-programming-crash-course.html", "Chapter 2 A brief R programming crash course 2.1 Variables 2.2 Vectors and element selection 2.3 Information about your vector 2.4 Sequences 2.5 The important bit: for loops", " Chapter 2 A brief R programming crash course To get started with making our own evolutionary model, we need to make a simple program in R that tracks an evolving population. To this end, you need to know something about the ingredients that simple programs use, namely variables, vectors/sequences and for-loops. Some of this may have already featured in your statistics or introduction to data science modules, but at this stage, getting some repetition about the sometimes bamboozling inner workings of R certainly does not hurt. Even the most field-oriented among you will use R extensively during your research projects, so the more exposure you can get to this environment, the better. Try to type along with the examples below and see whether they work. Give me a shout if something looks odd. 2.1 Variables A variable provides us with a named storage of data, allowing you to retrieve that bit of data when you want it. A variable in R can contain any type of data (e.g., a single number, a string of text, a vector of multiple values, etc). We assign data to a variable using a = or &lt;- operator (both can be used interchangeably) For example: # create a variable named var.1 and assign a value to it using the &lt;- operator var.1 &lt;- 25000 # create a variable named var.2 and assign a vector, c(), of numbers to it using the = operator var.2 = c(0,1,9.5,200) # a bit of text, surrounded by single &#39;&#39; or double &quot;&quot; quotes some.text &lt;- &quot;Swanpool beach&quot; 2.1.1 Naming variables Variables can have any name, but cannot start with a number and can only contain dot . and underscore _ characters as special characters. # this fails 2times_song_release_year &lt;- 1999 ## Error: &lt;text&gt;:2:2: unexpected symbol ## 1: # this fails ## 2: 2times_song_release_year ## ^ # this is fine release_year_2times &lt;- 1999 # this fails too release%year &lt;- 1999 ## Error: &lt;text&gt;:2:8: unexpected input ## 1: # this fails too ## 2: release%year &lt;- 1999 ## ^ 2.1.2 Changing the value stored by variables You can easily change values of variables, simply by assigning them a new one! The new value can be of a completely different type. # print the value of a variable, showing its current value print(var.1) ## [1] 25000 # change the value var.1 &lt;- &quot;some text instead!&quot; # print the new value print(var.1) ## [1] &quot;some text instead!&quot; You can always check the type of your variable using the typeof() function: typeof(var.1) ## [1] &quot;character&quot; typeof(var.2) ## [1] &quot;double&quot; As you see, typeof does not tell you var.2 is a vector of multiple values, but just focuses on the type of the values contained in them (in this case a double, which is another word for floating point value. If you want to find out if something is a vector of values, you have to look at the length of the variable (see below). 2.2 Vectors and element selection As you have seen in the example of var.2 above, variables can point to collections of multiple values (vectors). To create a vector, we use the c() function. We can subsequently get values of (groups of) individual elements by using the [[]] operator: # 1. create a vector of character elements using c() animals &lt;- c(&quot;Opossum&quot;,&quot;Dog&quot;,&quot;Pallas&#39;s leaf warbler&quot;) # 2. select a single element using the double square brackets [[]] print(animals[[3]]) ## [1] &quot;Pallas&#39;s leaf warbler&quot; # 3. obtain a selection of # multiple values using [] and # a vector of elements you want to select print(animals[c(2,3)]) ## [1] &quot;Dog&quot; &quot;Pallas&#39;s leaf warbler&quot; # 4. assign a new value to an existing element animals[[1]] &lt;- &quot;Click beetle&quot; print(animals) ## [1] &quot;Click beetle&quot; &quot;Dog&quot; &quot;Pallas&#39;s leaf warbler&quot; 2.2.1 Exercises What happens to the vector animals if you assign the name of your favorite animal (in quotes \"\", because text) to element 40? Assign the number 0.5 to element 10 of the animals vector. Try to multiple this value by 10, by typing animals[[10]]*10 what happens? Use typeof(animals[[10]]) to see what is going on. 2.3 Information about your vector You can obtain information about your vector by using a range of different functions, such as sum(): sums all values (only works with numbers obvz) unique() lists all unique values sort() sorts values. and there are lots more. Most often, however, you will use the length() function to obtain its size: length(x=animals) ## [1] 40 2.3.1 Exercise Using the standard iris dataset (available within in R by typing iris on the command line), find out the number of unique values for the column Sepal.Width. If you see iris but don’t know how you can access the column, try to search for it on the web. 2.4 Sequences Vectors are also used to contain sequences of numbers, which can either be generated with the from-to operator : or with the more explicit seq() function: # sequence from 1 to 10 some.seq &lt;- 1:10 # sequence from 10 to 1 reverse.seq &lt;- 10:1 # same, but using the sequence in some.seq and the rev() &#39;reverse&#39; function: reverse.seq.2 &lt;- rev(some.seq) # sequence from 10 to 1, using the seq() function, with a negative increment another.seq &lt;- seq(from=10,to=1,by=-1) # the seq() function is great if you want to take bigger steps: steps.of.5 &lt;- seq(from=3,to=29,by=5) We can also make vectors using repetitions of values, through rep(): # a vector of 300 zeros only.zeros &lt;- rep(x=0,times=300) # a vector of 0,1 values, repeated until a length of 13 is achieved zero.one &lt;- rep(x=c(0,1),length.out=13) 2.5 The important bit: for loops The point about programming is that you want to repeat actions multiple times. To this end, R offers you two different looping constructs: the while() loop and the for loop. In this practical, we focus on the for loop as it is more commonly used than while(). Best to begin by an example: # you need some vector of something # otherwise there will # be nothing to loop over # Here, I use a vector of numbers from 5 up to (&amp; including) 10 some.vec &lt;- 5:10 # component 1: the for statement within # parentheses () for (iterator in some.vec) { # component 2: the for body within curly braces {} # in which tasks # are performed # repeatedly for each value of iterator print(iterator) # I am also printing something else # for the sake of illustration print(&quot;Some text.&quot;) } ## [1] 5 ## [1] &quot;Some text.&quot; ## [1] 6 ## [1] &quot;Some text.&quot; ## [1] 7 ## [1] &quot;Some text.&quot; ## [1] 8 ## [1] &quot;Some text.&quot; ## [1] 9 ## [1] &quot;Some text.&quot; ## [1] 10 ## [1] &quot;Some text.&quot; From the printed output, you see that the iterator gets a new value every time the loop goes round. The message \"Some text\" is also repeatedly printed, but this value does not change. 2.5.1 Dissecting the for loop The loop starts with the keyword for, followed by parentheses (). Within those parentheses, we always start by declaring a new variable, which – in this case – I have called iterator, but you could have given it any valid name, like index or boring.practical. Each time the for loop goes round, the iterator variable gets assigned a new value. Which value? An element from a vector, which we have called here some.vec. The in keyword in between iterator and some.vec performs the assigning of these consecutive elements from some.vec to iterator. Hence, the first time the loop goes round, iterator receives the value of 5, as this is the first element of some.vec. Subsequently, the for loop enters the bit in between curly braces {}. The code in this part will be executed every time iterator gets a new value. In this case, the code is print(iterator), meaning it prints the current value of the iterator variable (which is 5) is printed to the screen. After this the subsequent print() statement is executed, which prints \"Some text\" to the screen. Next, the loop goes round again. Now the value of iterator will be 6. Again, 6 is printed by the print() statements in the {}-part and this goes on until all elements from some.vec have been assigned to iterator. Hence, the last value printed will be 10, after which the for loop exits. 2.5.2 Another example Just to throw in another example that is slightly different, let us calculate the product of elements of two vectors and sum those products: # generate two vectors with numbers; # vectors have the same length vec.1 &lt;- c(0.3,0.9,1.2,0.1,3.5) vec.2 &lt;- c(5,8,12,3,7) # check whether the length is indeed the same stopifnot(length(vec.1) == length(vec.2)) sum &lt;- 0 # loop not over the elements of the list # but over the element indices # (we can do so by creating a list from # 1 to the length of one of the vectors, # i.e., 1,2,3,...) for (idx in 1:length(vec.1)) { # use idx to obtain elements of both vectors # and add them to the total sum &lt;- sum + vec.1[[idx]] * vec.2[[idx]] } print(sum) ## [1] 47.9 2.5.3 Exercises Can you think of why we don’t we write for (idx in vec.1) as in the previous example? Could you change the code to store the sum that you obtain in each iteration in a list? I.e., that list should have the values print(cumul.list) ## [1] 1.5 8.7 23.1 23.4 47.9 OK now that we have some tools under our belts, let’s get going with evolution!! "],["an-evolutionary-model-of-the-hawk-dove-game.html", "Chapter 3 An evolutionary model of the hawk-dove game 3.1 Payoff matrices 3.2 Exercise 3.3 A haploid population genetical model of the Hawk-Dove game 3.4 Alleles 3.5 Life cycle 3.6 Fitness 3.7 Exercise 3.8 Evolutionary dynamics 3.9 Relation to \\(\\Delta p\\) in lecture slides (skip this if not interested) 3.10 Implementing our evolutionary algorithm", " Chapter 3 An evolutionary model of the hawk-dove game Why do we often find that competitors exhibit ritualized displays (e.g., threats such growling, baring one’s teeth) to decide fights with competitors, rather than engaging in escalated fights in order to kill the opponent? This question has been addressed by a simple evolutionary model, called the Hawk-Dove game. This influential model aims to sketch out how aggressive versus more restrained behaviours evolve when individuals compete with each other over resources. Here we analyze a deterministic version of this model, by focusing on a population consisting of i) aggressive hawks (denoted by \\(H\\)) who always fight and do not retreat; and ii) timid Doves (denoted by \\(D\\)), who may perform some threat display, but eventually will always retreat if the other individual starts a fight. 3.1 Payoff matrices We can summarize these interactions in a so-called payoff matrix, where the rows reflect the payoff to a focal player who either plays strategy \\(H\\) or \\(D\\), when it encounters other \\(H\\)s or \\(D\\)s (columns). focal \\(\\downarrow\\) opponent \\(\\rightarrow\\) \\(H\\) \\(D\\) \\(H\\) \\(\\frac{v-c}{2}\\) \\(v\\) \\(D\\) \\(0\\) \\(\\frac{v}{2}\\) 3.2 Exercise Can you explain in your words what each of the payoffs mean? Try to search for descriptions of the Hawk Dove game online if unclear. We will discuss the answer in class. 3.3 A haploid population genetical model of the Hawk-Dove game Although the Hawk-Dove game is often used as an example of evolutionary game theory, here we start from the ground up by developing a more rigorous model that is based on population genetics. Population genetics deals with all the genetic detail, so is more complete than evolutionary game theory. However, analyzing the formulas of the population genetics model is slightly more challenging, so this is why we will use R to simulate the model instead. By comparing whether predictions from evolutionary game theory match our population genetics model, we can see whether genetic detail matters, if at all. If predictions do not match, this may tell us that lack genetic assumptions in evolutionary game theory can lead to erroneous conclusions. Such exercises are worthwhile if you want to predict when a phenotypic gambit may be an accurate vs inaccurate description of the evolution of behaviour. 3.4 Alleles For the sake of simplicity, we assume that being a hawk or dove is the result of just two alleles at a single haploid locus! This is crazy of course, hardly any animal traits are haploid! Moreover, even fewer are chiefly the result of variation at a single locus only. The question is whether we would learn a similar amount from a hugely convoluted model with 1000s of loci… Let \\(p_{t}\\) be the frequency of the allele coding for \\(H\\) in the population at generation \\(t\\), while \\(1-p_{t}\\) is the frequency of the \\(D\\) allele in the population at generation \\(t\\). We assume that strategies are pure, meaning that an individual having the \\(H\\) or \\(D\\) allele will always be a hawk or dove respectively. Later on, we will consider a case where strategies are mixed, so that \\(p_{t}\\) does not reflect the frequency of the \\(H\\) allele, but the probability with which each individual plays \\(H\\) at each interaction. 3.5 Life cycle We assume that generations are discrete, implying that all individuals die after reproduction. Upon birth, a newborn individual fights or displays with other individuals a single time. From this interaction, it will collect a payoff as given in the payoff matrix above. The payoff is then proportional to the number of offspring the individual produces. 3.6 Fitness An individual reproduces according to the payoffs it has collected. Let us denote the fitness of a hawk and dove as \\(W_{H}\\) and \\(W_{D}\\) respectively, which we can interpret as the number of offspring produced by each of these types. Starting with the fitness of a focal dove \\(W_{D,t}\\) at generation \\(t\\), we have \\[\\begin{align} W_{D,t} &amp;= w_{0} + p_{t} (0) + \\left(1-p_{t} \\right) \\frac{v}{2} \\end{align}\\] the first element on the right-hand side of the equation above reflects so-called ‘baseline fitness’, which is the fitness that this individual accrues during other activities than displaying. It is assumed that baseline fitness is similar for hawks and doves. the second part reflects the probability that a dove meets a hawk (which has frequency \\(p_{t}\\)). It will then immediately retreat, hence collecting no payoff (but also incurring no costs), reflected by the \\((0)\\). the third part reflects the probability that a dove meets another dove (which has frequency \\(1-p_{t}\\)). In that case they will split the value of the resource, hence \\(v/2\\). 3.7 Exercise Based on similar reasoning as for \\(W_{D,t}\\) above, can you write down the fitness expression \\(W_{H,t}\\) for a focal hawk in generation \\(t\\)? Again, assume that there is some baseline fitness \\(w_{0}\\) accrued from other activities than fighting: \\[\\begin{align} W_{H,t} &amp;= w_{0} + \\ldots + \\ldots \\end{align}\\] Can fitnesses \\(W_{H,t}\\) and \\(W_{D,t}\\) be negative? 3.8 Evolutionary dynamics Now that we have derived fitness expressions of the dove and hawk alleles, let us consider how the frequencies of these alleles change over time. The frequency \\(p_{t+1}\\) of the hawk allele at time \\(t+1\\) is given by a surprisingly simple equation: \\[\\begin{align} p_{t+1} &amp;= p_{t} \\frac{W_{H}}{\\bar{W}_{t}} \\end{align}\\] This is a so-called recursion equation, tracking an allele frequency recursively from one generation to the next. Keep an eye on this equation, as we will need it later on. The term \\(\\bar{W}_{t}\\) in the expression above is the average fitness in the population in generation \\(t\\), given by \\[\\begin{align} \\bar{W} &amp;= p_{t} W_{H} + \\left(1 - p_{t} \\right ) W_{D} \\end{align}\\] The expression for \\(p_{t+1}\\) above tells you that if hawks do better than the average (\\(W_{H} &gt; \\bar{W}\\)), the frequency of the hawk allele will increase from one generation to the next, as \\(W_{H}/\\bar{W} &gt; 1\\). Similarly, if hawks do worse than average, we have \\(W_{H}/\\bar{W} &lt; 1\\) and the frequency of the hawk allele decreases. One advantage of our super-simple model is that we do not have derive a separate expression for the change in frequency of the dove allele!! This is simply \\(1-p_{t+1}\\). However, if we would consider more than two alleles per locus (or multiple loci), matters would be (far) more difficult. 3.9 Relation to \\(\\Delta p\\) in lecture slides (skip this if not interested) In the lecture slides we have seen that the change in allele frequency was given by \\[\\begin{align} \\Delta p = p_{t+1} - p_{t} = p_{t} \\left ( 1 - p_{t} \\right ) \\frac{ W_{H} - W_{D}}{\\bar{W}} \\end{align}\\] If you want to know how the above relates to the equation we have seen in the lecture slides, read this! If not interested, please skip ahead to the next section. How do we get from our recursion equation $p_{t+1} = $ to the one above? The clue is in the \\(\\Delta p = p_{t+1} - p_{t}\\). If we substitute here for our recursion equation of \\(p_{t+1}\\), we get: \\[\\begin{align} \\Delta p &amp;= p_{t+1} - p_{t} \\\\ &amp;= p_{t} \\frac{W_{H}}{\\bar{W}_{t}} - p_{t} \\quad \\text{substitute for }p_{t+1} \\\\ &amp;= p_{t} \\frac{W_{H}}{\\bar{W}_{t}} - p_{t} \\frac{\\bar{W_{t}}}{\\bar{W}_{t}} \\quad \\text{common demoninator} \\\\ &amp;= p_{t} \\frac{W_{H}}{\\bar{W}_{t}} - p_{t} \\frac{p_{t} W_{H} + \\left (1 - p_{t}\\right ) W_{D} }{\\bar{W}_{t}} \\quad \\text{expanding }\\bar{W} \\\\ &amp;= p_{t} \\left (1 - p_{t} \\right ) \\frac{W_{H}}{\\bar{W}_{t}} - p_{t} \\frac{\\left (1 - p_{t}\\right ) W_{D} }{\\bar{W}_{t}} \\quad \\text{clubbing terms of }W_{H} \\\\ &amp;= p_{t} \\left (1 - p_{t} \\right ) \\frac{W_{H} - W_{D}}{\\bar{W}_{t}} \\quad \\text{clubbing terms of }p_{t} \\left(1-p_{t} \\right) \\\\ \\end{align}\\] 3.10 Implementing our evolutionary algorithm "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
