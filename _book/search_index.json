<<<<<<< HEAD
[["a-brief-r-programming-crash-course.html", "Chapter 2 A brief R programming crash course 2.1 Variables 2.2 Vectors and element selection 2.3 Information about your vector 2.4 Sequences 2.5 The important bit: for loops", " Chapter 2 A brief R programming crash course To get started with making our own evolutionary model, we need to make a simple program in R that tracks an evolving population. To this end, you need to know something about the ingredients that simple programs use, namely variables, vectors/sequences and for-loops. Some of this may have already featured in your statistics or introduction to data science modules, but at this stage, getting some repetition about the sometimes bamboozling inner workings of R certainly does not hurt. Even the most field-oriented among you will use R extensively during your research projects, so the more exposure you can get to this environment, the better. Try to type along with the examples below and see whether they work. Give me a shout if something looks odd. 2.1 Variables A variable provides us with a named storage of data, allowing you to retrieve that bit of data when you want it. A variable in R can contain any type of data (e.g., a single number, a string of text, a vector of multiple values, etc). We assign data to a variable using a = or &lt;- operator (both can be used interchangeably) For example: # create a variable named var.1 and assign a value to it using the &lt;- operator var.1 &lt;- 25000 # create a variable named var.2 and assign a vector, c(), of numbers to it using the = operator var.2 = c(0,1,9.5,200) # a bit of text, surrounded by single &#39;&#39; or double &quot;&quot; quotes some.text &lt;- &quot;Swanpool beach&quot; 2.1.1 Naming variables Variables can have any name, but cannot start with a number and can only contain dot . and underscore _ characters as special characters. # this fails 2times_song_release_year &lt;- 1999 ## Error: &lt;text&gt;:2:2: unexpected symbol ## 1: # this fails ## 2: 2times_song_release_year ## ^ # this is fine release_year_2times &lt;- 1999 # this fails too release%year &lt;- 1999 ## Error: &lt;text&gt;:2:8: unexpected input ## 1: # this fails too ## 2: release%year &lt;- 1999 ## ^ 2.1.2 Changing the value stored by variables You can easily change values of variables, simply by assigning them a new one! The new value can be of a completely different type. # print the value of a variable, showing its current value print(var.1) ## [1] 25000 # change the value var.1 &lt;- &quot;some text instead!&quot; # print the new value print(var.1) ## [1] &quot;some text instead!&quot; You can always check the type of your variable using the class() function: class(var.1) ## [1] &quot;character&quot; class(var.2) ## [1] &quot;numeric&quot; As you see, class() does not tell you that var.2 is a vector of multiple values, but just focuses on the type of the values contained in them (in this case a numeric, which is R’s way of saying that we are dealing with a real number). If you want to find out if something is a vector of values, you have to look at the length of the variable (see below). 2.2 Vectors and element selection As you have seen in the example of var.2 above, variables can point to collections of multiple values (vectors). To create a vector, we use the c() function. We can subsequently get values of (groups of) individual elements by using the [[]] operator: # 1. create a vector of character elements using c() animals &lt;- c(&quot;Opossum&quot;,&quot;Dog&quot;,&quot;Pallas&#39;s leaf warbler&quot;) # 2. select a single element using the double square brackets [[]] print(animals[[3]]) ## [1] &quot;Pallas&#39;s leaf warbler&quot; # 3. obtain a selection of # multiple values using [] and # a vector of elements you want to select print(animals[c(2,3)]) ## [1] &quot;Dog&quot; &quot;Pallas&#39;s leaf warbler&quot; # 4. assign a new value to an existing element animals[[1]] &lt;- &quot;Click beetle&quot; print(animals) ## [1] &quot;Click beetle&quot; &quot;Dog&quot; &quot;Pallas&#39;s leaf warbler&quot; 2.2.1 Exercises What happens to the vector animals if you assign the name of your favorite animal (in quotes \"\", because text) to element 40? Assign the number 0.5 to element 10 of the animals vector. Try to multiply this value by 10, by typing animals[[10]]*10 what happens? Use class(animals[[10]]) to see what is going on. 2.3 Information about your vector You can obtain information about your vector by using a range of different functions, such as sum(): sums all values (only works with numbers obvz) unique() lists all unique values sort() sorts values. and there are lots more. Most often, however, you will use the length() function to obtain its size: length(x=animals) ## [1] 40 2.3.1 Exercise Using the standard iris dataset (available within in R by typing iris on the command line), find out the number of unique values for the column Sepal.Width. If you see iris but don’t know how you can access the column, try to search for it on the web. 2.4 Sequences Vectors are also used to contain sequences of numbers, which can either be generated with the from-to operator : or with the more explicit seq() function: # sequence from 1 to 10 some.seq &lt;- 1:10 # sequence from 10 to 1 reverse.seq &lt;- 10:1 # same, but using the sequence in some.seq and the rev() &#39;reverse&#39; function: reverse.seq.2 &lt;- rev(some.seq) # sequence from 10 to 1, using the seq() function, with a negative increment another.seq &lt;- seq(from=10,to=1,by=-1) # the seq() function is great if you want to take bigger steps: steps.of.5 &lt;- seq(from=3,to=29,by=5) We can also make vectors using repetitions of values, through rep(): # a vector of 300 zeros only.zeros &lt;- rep(x=0,times=300) # a vector of 0,1 values, repeated until a length of 13 is achieved zero.one &lt;- rep(x=c(0,1),length.out=13) 2.5 The important bit: for loops The point about programming is that you want to repeat actions multiple times. To this end, R offers you two different looping constructs: the while() loop and the for loop. In this practical, we focus on the for loop as it is more commonly used than while(). Best to begin by an example: # you need some vector of something # otherwise there will # be nothing to loop over # Here, I use a vector of numbers from 5 up to (&amp; including) 10 some.vec &lt;- 5:10 # component 1: the for statement within # parentheses () for (iterator in some.vec) { # component 2: the for body within curly braces {} # in which tasks # are performed # repeatedly for each value of iterator print(iterator) # I am also printing something else # for the sake of illustration print(&quot;Some text.&quot;) } ## [1] 5 ## [1] &quot;Some text.&quot; ## [1] 6 ## [1] &quot;Some text.&quot; ## [1] 7 ## [1] &quot;Some text.&quot; ## [1] 8 ## [1] &quot;Some text.&quot; ## [1] 9 ## [1] &quot;Some text.&quot; ## [1] 10 ## [1] &quot;Some text.&quot; From the printed output, you see that the iterator gets a new value every time the loop goes round. The message \"Some text\" is also repeatedly printed, but this value does not change. 2.5.1 Dissecting the for loop The loop starts with the keyword for, followed by parentheses (). Within those parentheses, we always start by declaring a new variable, which – in this case – I have called iterator, but you could have given it any valid name, like index or boring.practical. Each time the for loop goes round, the iterator variable gets assigned a new value. Which value? An element from a vector, which we have called here some.vec. The in keyword in between iterator and some.vec performs the assigning of these consecutive elements from some.vec to iterator. Hence, the first time the loop goes round, iterator receives the value of 5, as this is the first element of some.vec. Subsequently, the for loop enters the bit in between curly braces {}. The code in this part will be executed every time iterator gets a new value. In this case, the code is print(iterator), meaning it prints the current value of the iterator variable (which is 5) is printed to the screen. After this the subsequent print() statement is executed, which prints \"Some text\" to the screen. Next, the loop goes round again. Now the value of iterator will be 6. Again, 6 is printed by the print() statements in the {}-part and this goes on until all elements from some.vec have been assigned to iterator. Hence, the last value printed will be 10, after which the for loop exits. 2.5.2 Another example Just to throw in another example that is slightly different, let us calculate the product of elements of two vectors and sum those products: # generate two vectors with numbers; # vectors have the same length vec.1 &lt;- c(0.3,0.9,1.2,0.1,3.5) vec.2 &lt;- c(5,8,12,3,7) # check whether the length is indeed the same stopifnot(length(vec.1) == length(vec.2)) sum &lt;- 0 # loop not over the elements of the list # but over the element indices # (we can do so by creating a list from # 1 to the length of one of the vectors, # i.e., 1,2,3,...) for (idx in 1:length(vec.1)) { # use idx to obtain elements of both vectors # and add them to the total sum &lt;- sum + vec.1[[idx]] * vec.2[[idx]] } print(sum) ## [1] 47.9 2.5.3 Exercises In the first example of a for loop (right below section 2.5), we used the statement for (iterator in some.vec). The statement in the second example of a for loop is slightly more complicated, however: for (idx in 1:length(vec.1)). Can you explain the difference between the two statements? Could you change the code to store the sum that you obtain in each iteration in a list? I.e., that list should have the values print(cumul.list) ## [1] 1.5 8.7 23.1 23.4 47.9 Now that we have some tools under our belts, let’s get going with evolution!! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
=======
[["individual-based-simulations-and-drift.html", "Chapter 4 Individual-based simulations and drift 4.1 Before you start this practical 4.2 Installing the driftSim package 4.3 Individual-based models 4.4 Life cycle 4.5 Exercise: limiting assumptions 4.6 Running the driftSim package 4.7 Exercise: plotting the output from the driftSim package 4.8 Exercise: change the initial frequency of hawks 4.9 Exercise: increase the population size", " Chapter 4 Individual-based simulations and drift Previously, the model of the Hawk-Dove game that we have used was deterministic, where multiple runs for the same values of the parameters \\(v\\) and \\(c\\) always result in the same outcome. In reality, however, evolution does not work like that, as quite a number of biological processes are the result of chance. To give some examples: chance plays a big role in determining whether a mutation occurs or not, whether or not you happen to encounter a hawk rather than a dove, which gamete actually contributes to the next generation or which offspring manages to survive in order to reproduce. Introducing chance in models of evolution makes these models stochastic, meaning that any two runs of the same model (with the same values of the parameters) does not necessarily result in the same outcome. Stochasticity in evolution introduces a phenomenon called ‘genetic drift’ which we will explore in this practical. Genetic drift can – particularly in small populations – dramatically affect the course of evolution! 4.1 Before you start this practical First, please be reminded to use one of the Rstudio servers rather than your local installation of R. This is because we will be using some custom-built R packages, which themselves require extensions like Rtools that can be a bit of a pain to install on some computers. Luckily, this should all have been done for you on the Rstudio server. Next, when logged in on the Rstudio server, please use R version 4.1.1. And finally, it may be worthwhile to remove variables from our previous session, which we do by typing in the following # clean all R variables rm(list=ls()) 4.2 Installing the driftSim package Now, let’s get started. In this part of the practical, we will explore a model that includes stochasticity. Such a model is provided in the R package driftSim. To install this package, do the following: if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) library(&quot;devtools&quot;) devtools::install_github(&quot;bramkuijper/driftSim&quot;) If you get a message like Skipping install of 'driftSim' from a github remote, the SHA1 (27e9c52c) has not changed since last install. Useforce = TRUEto force installation, R is simply telling you the package has already been installed. Consequently, you can just move on to the next step. Then we can load the library using: library(&quot;driftSim&quot;) 4.3 Individual-based models This package contains what we call an individual-based simulation, which is nothing more than a computer program that models individuals and their actions (e.g., surviving, fighting, reproducing). By contrast, in the previous set of exercises, we did not focus on individuals too much, but rather on an analytical model which tracked the population-wide frequency \\(p_{t}\\) of hawks. Indeed, keeping track of a single population-wide frequency \\(p_{t}\\) is a lot simpler than keeping track of thousands or even millions of individuals. However, such simplicity also comes also at a price, which will be the focus of this chapter. While the simulation package driftSim runs within R, under the hood it is coded in the low-level programming language C++. This is because large simulations tend to be very slow in R, but run much faster in C++. Below you see a little snippet from this package, reflecting the properties of single individual: struct Individual { bool is_hawk; // TRUE/FALSE individual is hawk or dove double payoff; // the value of the payoff double prob_hawk; // the probability that this individual develops as a hawk in early life (only used when strategies are mixed) }; The program then simulates a finite population of \\(N\\) of these individuals. You might remember that the analytical model in the previous chapter assumed infinitely many individuals, so while the individual-based model is an absolute loser when it comes to speed, it is already a winner when it comes to increased realism! 4.4 Life cycle At the start of each generation, each individual interacts with a randomly chosen other individual and either attacks (hawk) or displays (dove). It gets its payoffs based on the same payoff matrix as we used in the deterministic model in the previous chapter. Subsequently, we then produce \\(N\\) newborn offspring from this population. Parents of each of these offspring are sampled from the previous generation, with individuals who have a larger payoff being more likely to be selected than individuals which have a lower payoff. 4.5 Exercise: limiting assumptions Individual-based simulations are often used to relax many of the limiting assumptions present in deterministic models, as writing computer code allows for much more flexibility than when using mathematical formulas. We have already seen how individual-based simulations have relaxed one assumption of the popoulation genetics mode, namely the fact that population sizes can now be finite, rather than infinite. Can you list three other limiting assumptions from the deterministic population genetics model that you would like to relax? For each assumption, can you think how relaxing the assumption could potentially affect results? (It is often much easier to spell out what is wrong with a model than to spell out how addressing it will change outcomes!) 4.6 Running the driftSim package The driftSim package contains a single function, called runSimulation(). Before running this function, please inspect the documentation by typing ?runSimulation() in your R console, after which a help page should show up. Let us start with a simple example run with a population size of \\(N=10\\), \\(v=1.0\\), \\(c=2.0\\) and a bunch of different parameters. Most are not so important, except that the initial frequency \\(p_{t=0}\\) of hawks which is set at \\(p_{t=0} = 0.25\\). runSimulation(N=10,v=1.0,c=2.0,is_pure=T,mu=0,max_time=10,pHawk_init=0.25,output_nth_generation=1,sd_pHawkMixed=0) ## generation freq_Hawk mean_pHawkMixed sd_pHawkMixed ## 1 1 0 0 0 ## 2 2 0 0 0 ## 3 3 0 0 0 ## 4 4 0 0 0 ## 5 5 0 0 0 ## 6 6 0 0 0 ## 7 7 0 0 0 ## 8 8 0 0 0 ## 9 9 0 0 0 ## 10 10 0 0 0 In this way, however, we cannot use the data from the runSimulation() function, as it will simply be printed out to the console, but it is not stored anywhere. To make sure that the resulting data will be contained in a data.frame, we assign the return values from the runSimulation() function to a variable, like this: my.data &lt;- runSimulation(N=10,v=1.0,c=2.0,is_pure=T,mu=0,max_time=10,pHawk_init=0.25,output_nth_generation=1,sd_pHawkMixed=0) The my.data variable points to a data.frame with the following columns: 1. generation: generation time point 2. freq_Hawk: the frequency of hawks in the population, the variable of interest 3. mean_pHawkMixed: in case hawks and doves are the result of a mixed strategy, this is the (evolving) probability that any individual will develop as hawk at the start of its life. This is 0 in case is_pure=T, when we consider pure strategies of hawks and Doves 4. sd_pHawkMixed: variation among individuals in their ability to develop as hawks (only nonzero when is_pure=F) 4.7 Exercise: plotting the output from the driftSim package Make a plot where plot generation on the \\(x\\)-axis and freq_Hawk on the \\(y\\)-axis. Re-run your simulation at least 10 times. What happens (typically) with the hawk allele? 4.8 Exercise: change the initial frequency of hawks Now, change the initial frequency of hawks by changing the value of pHawk_init to pHawk_init=0.75. Run the simulation for a long time, for example max_time=500. What happens now with the frequency of hawks? What does that tell you about the differences between the analytical model and the current one? Do we still reach the predicted equilibrium frequency of hawks \\(\\hat{p} = v/c\\)? 4.9 Exercise: increase the population size Now, try the same with a population size of \\(N=500\\). What happens now? "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
>>>>>>> 11de7ccaede8b01b66b5bf835a687cb1c1fe563e
